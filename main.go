package main

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	"os"
)

// TODO: write E2E tests using a sample .NET app and docker-compose
// TODO: Currently, only a parser for .NET is available, make it possible to choose another parser
// using a CLI flag

func main() {
	// read from stdin
	info, err := os.Stdin.Stat()
	if err != nil {
		panic(err)
	}

	if info.Mode()&os.ModeCharDevice != 0 || info.Mode()&os.ModeNamedPipe == 0 {
		fmt.Println("The command is intended to work with pipes.")
		fmt.Println("Usage: cat dd-trace-dotnet-log-file | dd-trace-dotnet-unterminated-span-count")
		return
	}

	var (
		ddTraceLogFilePath string
		resultJSONFilePath string
	)

	flag.StringVar(&ddTraceLogFilePath, "input", "./input.log", "path to the dd-trace-dotnet log file to be analyzed")
	flag.StringVar(&resultJSONFilePath, "output", "./output.json", "path to the output JSON file generated by this program")

	inputFileHandle, err := os.Open(ddTraceLogFilePath)
	if err != nil {
		panic(err)
	}
	reader := bufio.NewReader(inputFileHandle)

	parser := dotnetParser{}
	traces := parser.extractTracesFromLogStream(reader)

	unclosedSpans := findUnterminatedSpans(traces)

	result, err2 := json.MarshalIndent(map[string]interface{}{
		"analyzedTraceCount":    len(traces),
		"unterminatedSpanCount": len(unclosedSpans),
		"unterminatedSpans":     unclosedSpans,
	}, "", "  ")
	if err2 != nil {
		panic(err2)
	}

	if err = os.WriteFile(resultJSONFilePath, result, 0644); err != nil {
		panic(err)
	}

	if len(unclosedSpans) == 0 {
		os.Exit(0)
	} else {
		os.Exit(1)
	}
}
